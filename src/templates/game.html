<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paco's Tapas Runner</title>
    <script src="https://telegram.org/js/games.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #1a1a1a; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { width: 100%; height: 100%; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        #game-over-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; text-align: center; }
        .btn { background: #FFD700; color: #000; padding: 15px 30px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-top: 20px; font-size: 1.2rem; }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <h2>ABRIENDO EL BAR...</h2>
        <p>Sacando los palillos...</p>
    </div>

    <div id="game-over-screen">
        <h1 style="color: #ff0000; font-size: 3rem;">Â¡LA CUENTA!</h1>
        <h2 id="final-score-text">PuntuaciÃ³n: 0</h2>
        <p id="status-text">Guardando puntos en la barra...</p>
        <button class="btn" onclick="window.location.reload()">JUGAR OTRA VEZ</button>
    </div>

    <div id="game-container"></div>

    <script type="module">
        const USER_ID = "{{ user_id }}";
        const INLINE_MESSAGE_ID = "{{ inline_message_id }}";
        const SECRET = "{{ secret }}";

        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
            scene: { preload: preload, create: create, update: update }
        };

        const game = new Phaser.Game(config);
        let player, items, background, bar, score = 0, lives = 3, scoreText, livesText, timerText, gameActive = true, isInvincible = false, timeLeft = 45;

        function preload() {
            // Load assets
            this.load.image('palillo', '/static/game/palillo.png');
            this.load.image('croqueta', '/static/game/croqueta.png');
            this.load.image('aguacate', '/static/game/aguacate.png');
            this.load.image('carajillo', '/static/game/carajillo.png');
            this.load.image('jamon', '/static/game/jamon.png');
            this.load.image('sushi', '/static/game/sushi.png');
            this.load.image('factura', '/static/game/factura.png');
            this.load.image('baldosa', '/static/game/baldosa.png');
            this.load.image('barra', '/static/game/barra.png');
            this.load.image('servilleta', '/static/game/servilleta.png');
        }

        function create() {
            document.getElementById('loading-overlay').style.display = 'none';

            // Background (Tiled)
            background = this.add.tileSprite(config.width / 2, config.height / 2, config.width, config.height, 'baldosa');

            // Bar at the bottom
            bar = this.add.tileSprite(config.width / 2, config.height - 20, config.width, 40, 'barra');
            this.physics.add.existing(bar, true); // Static body for the bar if needed, or just visual

            // Player
            player = this.physics.add.sprite(config.width / 2, config.height - 80, 'palillo');
            player.setCollideWorldBounds(true);
            player.setBodySize(10, 80); // Adjust hitbox for the toothpick

            items = this.physics.add.group();

            // UI
            scoreText = this.add.text(20, 20, 'CUÃ‘ADISMO: 0', { fontSize: '24px', fontWeight: 'bold', fill: '#FFD700', stroke: '#000', strokeThickness: 4, fontFamily: 'Segoe UI' });
            livesText = this.add.text(20, 60, 'SERVILLETAS: 3', { fontSize: '20px', fill: '#FFF', stroke: '#000', strokeThickness: 3 });
            timerText = this.add.text(config.width - 180, 20, 'TIEMPO: ' + timeLeft, { fontSize: '24px', fill: '#FFF', stroke: '#000', strokeThickness: 3 });

            // Initial lives icons
            updateLivesDisplay.call(this);

            this.input.on('pointermove', (pointer) => {
                if (gameActive) {
                    player.x = pointer.x;
                }
            });

            // Spawner
            this.time.addEvent({ delay: 600, callback: spawnRandomItem, callbackScope: this, loop: true });

            // Timer
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    if (!gameActive) return;
                    timeLeft--;
                    timerText.setText('TIEMPO: ' + timeLeft);
                    if (timeLeft <= 0) gameOver.call(this, score);
                },
                callbackScope: this, loop: true
            });

            this.physics.add.overlap(player, items, handleCollision, null, this);
        }

        function spawnRandomItem() {
            if (!gameActive) return;
            const x = Phaser.Math.Between(40, config.width - 40);
            const rand = Math.random();
            let type;

            // Spawn logic probabilities
            if (rand < 0.50) type = 'croqueta'; // 50% Common Good
            else if (rand < 0.75) type = 'aguacate'; // 25% Common Bad
            else if (rand < 0.85) type = 'sushi'; // 10% Rare Bad
            else if (rand < 0.92) type = 'factura'; // 7% Points Bad
            else if (rand < 0.98) type = 'jamon'; // 6% Rare Good
            else type = 'carajillo'; // 2% Power-up

            const item = items.create(x, -50, type);
            item.setData('type', type);

            // Random rotation for visual flair
            item.setAngularVelocity(Phaser.Math.Between(-100, 100));

            // Speed increases with score
            const speed = 250 + (score / 3);
            if (type === 'jamon') item.setVelocityY(speed * 1.5); // Jamon falls faster
            else if (type === 'factura') item.setVelocityY(speed * 0.8); // Factura falls slower (floating)
            else item.setVelocityY(speed);
        }

        function handleCollision(player, item) {
            const type = item.getData('type');
            item.destroy();

            // FX
            this.cameras.main.shake(50, 0.005);

            if (type === 'croqueta') {
                score += 10;
                showFloatingText.call(this, player.x, player.y, '+10', '#FFD700');
            } else if (type === 'jamon') {
                score += 50;
                showFloatingText.call(this, player.x, player.y, 'Â¡IBÃ‰RICO! +50', '#FF0000');
            } else if (type === 'aguacate' || type === 'sushi') {
                if (!isInvincible) {
                    lives--;
                    updateLivesDisplay.call(this);
                    this.cameras.main.shake(250, 0.02);
                    showFloatingText.call(this, player.x, player.y, 'Â¡VETE A UN STARBUCKS!', '#00FF00');
                    if (lives <= 0) gameOver.call(this, score);
                } else {
                    score += 25; // Smash bad items when invincible
                    showFloatingText.call(this, player.x, player.y, 'Â¡CRUNCH!', '#FFFF00');
                }
            } else if (type === 'factura') {
                 if (!isInvincible) {
                    score = Math.max(0, score - 50);
                    showFloatingText.call(this, player.x, player.y, 'Â¡DOLOROSA! -50', '#888888');
                 }
            } else if (type === 'carajillo') {
                isInvincible = true;
                player.setTint(0xFFD700);
                player.setScale(1.5);
                showFloatingText.call(this, player.x, player.y, 'Â¡OÃDO COCINA!', '#FFFFFF');
                this.time.delayedCall(6000, () => {
                    isInvincible = false;
                    player.clearTint();
                    player.setScale(1);
                });
            }
            scoreText.setText('CUÃ‘ADISMO: ' + score);
        }

        function showFloatingText(x, y, message, color) {
            let text = this.add.text(x, y - 20, message, { fontSize: '20px', fontStyle: 'bold', fill: color, stroke: '#000', strokeThickness: 3 });
            this.tweens.add({
                targets: text,
                y: y - 80,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => text.destroy()
            });
        }

        function updateLivesDisplay() {
            let text = "SERVILLETAS: ";
            // Could use images here, but text emoji is fine for now, or use the servilleta sprite if wanted.
            // Let's stick to emoji for clarity in text field, or maybe add sprites?
            // Reverting to simple text to match style
            for(let i=0; i<lives; i++) text += "ðŸ§»";
            livesText.setText(text);
        }

        function update() {
            // Parallax background
            background.tilePositionY -= 1;

            items.children.iterate(child => {
                if (child && child.y > config.height + 50) child.destroy();
            });
        }

        async function getHash(message) {
            if (window.crypto && crypto.subtle) {
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            } else {
                return "unsafe-" + btoa(message);
            }
        }

        async function gameOver(finalScore) {
            if (!gameActive) return;
            gameActive = false;

            this.physics.pause();
            player.setTint(0xff0000);

            const screen = document.getElementById('game-over-screen');
            const scoreDisplay = document.getElementById('final-score-text');
            const statusDisplay = document.getElementById('status-text');
            scoreDisplay.innerText = "PuntuaciÃ³n: " + finalScore;
            screen.style.display = 'flex';

            const hash = await getHash(`${USER_ID}${finalScore}${SECRET}`);
            try {
                const response = await fetch('/game/score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: USER_ID, score: finalScore, inline_message_id: INLINE_MESSAGE_ID, hash: hash })
                });
                if (response.ok) statusDisplay.innerText = "Â¡Puntos guardados en el ranking!";
                else statusDisplay.innerText = "Puntos no guardados (Error de servidor)";
            } catch (e) {
                console.error("Score submission error", e);
                statusDisplay.innerText = "Error de conexiÃ³n al guardar puntos.";
            }
        }
    </script>
</body>
</html>
